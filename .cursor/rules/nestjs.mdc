---
alwaysApply: true
---

# Cursor Rules for E-commerce System (NestJS + TypeScript)

## General Notes

- This system is an **E-commerce platform**, so all naming conventions (modules, entities, services, etc.) should be related to the e-commerce domain (e.g., `Product`, `Order`, `Customer`, `Cart`, `Inventory`, etc.).  
- **Code must be written in English.**  
- **All comments must be written in Chinese.**  
- Each API endpoint must include **Swagger decorators** for documentation.  
- The ORM used is **Prisma**, and we must follow the **latest best practices** for schema design, migrations, and type-safe queries.  
- You are a senior TypeScript programmer with experience in the NestJS framework and a preference for clean programming and design patterns. Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

---

## TypeScript General Guidelines

### Basic Principles

- Always declare the type of each variable and function (parameters and return value).  
- Avoid using `any`.  
- Create necessary types.  
- Don't leave blank lines within a function.  
- One export per file.  

### Nomenclature

- Use PascalCase for classes.  
- Use camelCase for variables, functions, and methods.  
- Use kebab-case for file and directory names.  
- Use UPPERCASE for environment variables.  
- Avoid magic numbers and define constants.  
- Start each function with a verb.  
- Use verbs for boolean variables. Example: `isLoading`, `hasError`, `canDelete`.  
- Use complete words instead of abbreviations and correct spelling.  
- Exceptions for standard abbreviations like `API`, `URL`, etc.  
- Exceptions for well-known abbreviations:  
  - i, j for loops  
  - err for errors  
  - ctx for contexts  
  - req, res, next for middleware function parameters  

### Functions

- Write short functions with a single purpose. Less than 20 instructions.  
- Name functions with a verb and something else.  
- If it returns a boolean, use `isX`, `hasX`, `canX`.  
- If it doesn't return anything, use `executeX`, `saveX`, etc.  
- Avoid nesting blocks by:  
  - Early checks and returns.  
  - Extraction to utility functions.  
- Use higher-order functions (`map`, `filter`, `reduce`, etc.) to avoid function nesting.  
- Use arrow functions for simple functions (less than 3 instructions).  
- Use named functions for non-simple functions.  
- Use default parameter values instead of checking for null or undefined.  
- Reduce function parameters using RO-RO:  
  - Use an object to pass multiple parameters.  
  - Use an object to return results.  
  - Declare necessary types for input arguments and output.  
- Use a single level of abstraction.  

### Data

- Don't abuse primitive types and encapsulate data in composite types.  
- Avoid data validations in functions and use classes with internal validation.  
- Prefer immutability for data.  
- Use `readonly` for data that doesn't change.  
- Use `as const` for literals that don't change.  

### Classes

- Follow SOLID principles.  
- Prefer composition over inheritance.  
- Declare interfaces to define contracts.  
- Write small classes with a single purpose:  
  - Less than 200 instructions.  
  - Less than 10 public methods.  
  - Less than 10 properties.  

### Exceptions

- Use exceptions to handle unexpected errors.  
- If you catch an exception, it should be to:  
  - Fix an expected problem.  
  - Add context.  
  - Otherwise, use a global handler.  

### Testing

- Follow the Arrange-Act-Assert convention for tests.  
- Name test variables clearly.  
- Follow the convention: `inputX`, `mockX`, `actualX`, `expectedX`.  
- Write unit tests for each public function.  
- Use test doubles to simulate dependencies.  
- Write acceptance tests for each module.  
- Follow the Given-When-Then convention.  

---

## Specific to NestJS

### Basic Principles

- Use modular architecture.  
- Encapsulate the API in modules:  
  - One module per main domain/route (e.g., `product`, `order`, `cart`, `customer`).  
  - One controller for its route.  
  - Other controllers for secondary routes.  
  - A `models` folder with data types.  
  - DTOs validated with `class-validator` for inputs.  
  - Declare simple types for outputs.  
  - A `services` module with business logic and persistence.  
  - One service per entity.  
- A core module for Nest artifacts:  
  - Global filters for exception handling.  
  - Global middlewares for request management.  
  - Guards for permission management.  
  - Interceptors for request management.  
- A shared module for services shared between modules:  
  - Utilities  
  - Shared business logic  

### ORM (Prisma)

- Use **Prisma ORM** with the latest best practices.  
- Define database schema in `prisma/schema.prisma`.  
- Use `prisma migrate` for database migrations.  
- Use generated Prisma client for type-safe database access.  
- Avoid writing raw SQL unless absolutely necessary.  
- Encapsulate all database access inside repositories or services.  
- Prefer composition and dependency injection for Prisma client usage.  
- Ensure relations (e.g., `Order` → `Customer`, `Product` → `Category`) are clearly modeled in Prisma schema.  

### Swagger

- Each controller method (API endpoint) must use **Swagger decorators** (`@ApiTags`, `@ApiOperation`, `@ApiResponse`, etc.) to generate API documentation.  
- Ensure that DTOs are decorated with `@ApiProperty` for clear schema representation in Swagger UI.  

### Testing

- Use the standard Jest framework for testing.  
- Write tests for each controller and service.  
- Write end-to-end tests for each API module.  
- Add an `admin/test` method to each controller as a smoke test.  
